<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SplitTab — Split your bill easily</title>
  <style>
    *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', system-ui, sans-serif;
      background: #fafafa;
      color: #111;
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
    }

    header {
      width: 100%;
      padding: 28px 24px 0;
      display: flex;
      justify-content: center;
      position: relative;
    }



    main {
      flex: 1;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 40px 24px;
      text-align: center;
      width: 100%;
      max-width: 600px;
    }

    /* Hero receipt visual */
    .hero-visual {
      position: relative;
      width: 240px;
      height: 170px;
      margin-bottom: 48px;
    }

    .receipt-card {
      position: absolute;
      border-radius: 10px;
      box-shadow: 0 4px 20px rgba(0,0,0,0.1);
    }

    .receipt-card:nth-child(1) {
      width: 155px; height: 105px;
      top: 0; left: 8px;
      transform: rotate(-7deg);
      background: linear-gradient(135deg, #ede9ff, #c4b5fd);
      opacity: 0.75;
    }

    .receipt-card:nth-child(2) {
      width: 155px; height: 105px;
      top: 8px; right: 8px;
      transform: rotate(5deg);
      background: linear-gradient(135deg, #fce7f3, #f9a8d4);
      opacity: 0.75;
    }

    .receipt-card:nth-child(3) {
      width: 170px; height: 120px;
      bottom: 0; left: 50%;
      transform: translateX(-50%) rotate(-1.5deg);
      background: #fff;
      border: 1px solid #e5e7eb;
      z-index: 3;
      padding: 14px 16px;
      display: flex;
      flex-direction: column;
      gap: 7px;
    }

    .mock-line {
      height: 7px;
      background: #e5e7eb;
      border-radius: 3px;
    }

    h1 {
      font-size: clamp(26px, 6vw, 40px);
      font-weight: 700;
      line-height: 1.2;
      letter-spacing: -0.025em;
      margin-bottom: 16px;
    }

    .tagline {
      font-size: 16px;
      color: #6b7280;
      line-height: 1.65;
      max-width: 390px;
      margin-bottom: 36px;
    }

    .btn-upload {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      background: #111;
      color: #fff;
      border: none;
      border-radius: 100px;
      padding: 15px 32px;
      font-size: 16px;
      font-weight: 500;
      cursor: pointer;
      font-family: inherit;
      transition: opacity 0.15s, transform 0.1s;
    }

    .btn-upload:hover { opacity: 0.82; }
    .btn-upload:active { transform: scale(0.97); }

    #file-input { display: none; }

    .features {
      margin-top: 28px;
      color: #9ca3af;
      font-size: 13px;
      line-height: 2;
    }

    footer {
      padding: 32px 24px;
      text-align: center;
      color: #9ca3af;
      font-size: 12px;
      line-height: 1.8;
      border-top: 1px solid #f0f0f0;
      width: 100%;
    }

    /* Loading overlay */
    #loading {
      display: none;
      position: fixed;
      inset: 0;
      background: rgba(255,255,255,0.96);
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 1000;
      gap: 16px;
    }

    #loading.show { display: flex; }

    .loader-ring {
      width: 44px;
      height: 44px;
      border: 3px solid #e5e7eb;
      border-top-color: #111;
      border-radius: 50%;
      animation: spin 0.7s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .loader-status { font-size: 15px; color: #374151; font-weight: 500; }
    .loader-detail { font-size: 13px; color: #9ca3af; }

    .progress-track {
      width: 180px;
      height: 3px;
      background: #e5e7eb;
      border-radius: 2px;
    }

    .progress-bar {
      height: 100%;
      background: #111;
      border-radius: 2px;
      width: 0%;
      transition: width 0.25s ease;
    }

    /* Error toast */
    #toast {
      display: none;
      position: fixed;
      bottom: 24px;
      left: 50%;
      transform: translateX(-50%);
      background: #ef4444;
      color: white;
      padding: 12px 20px;
      border-radius: 8px;
      font-size: 14px;
      z-index: 2000;
      max-width: 320px;
      text-align: center;
    }
  </style>
</head>
<body>

<header>
  <svg width="28" height="34" viewBox="0 0 28 34" fill="none" xmlns="http://www.w3.org/2000/svg">
    <path d="M14 2C14 2 21 10 21 19C21 24.5 18 29 14 31C10 29 7 24.5 7 19C7 10 14 2 14 2Z" fill="#111"/>
    <path d="M14 17C14 17 17 20.5 17 24C17 26.2 15.8 27.8 14 28.8C12.2 27.8 11 26.2 11 24C11 20.5 14 17 14 17Z" fill="white"/>
  </svg>
</header>

<main>
  <div class="hero-visual">
    <div class="receipt-card"></div>
    <div class="receipt-card"></div>
    <div class="receipt-card">
      <div class="mock-line" style="width:78%"></div>
      <div class="mock-line" style="width:55%"></div>
      <div class="mock-line" style="width:68%"></div>
      <div class="mock-line" style="width:48%"></div>
      <div class="mock-line" style="background:#111; width:62%; margin-top:2px"></div>
    </div>
  </div>

  <h1>Split your bill,<br>stress-free</h1>
  <p class="tagline">Upload a photo of your receipt. We'll scan the items so you can fairly split the bill with your group — down to the last penny.</p>

  <button class="btn-upload" onclick="document.getElementById('file-input').click()">
    <svg width="17" height="17" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
      <path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/>
      <polyline points="17 8 12 3 7 8"/>
      <line x1="12" y1="3" x2="12" y2="15"/>
    </svg>
    Upload a receipt
  </button>

  <input type="file" id="file-input" accept="image/jpeg,image/png,image/webp,image/gif,image/bmp,image/tiff" onchange="processReceipt(event)">

  <div class="features">
    ✦ Claude Vision &nbsp;·&nbsp; Per-item fair splitting &nbsp;·&nbsp; Free to use
  </div>
</main>

<footer>
  Receipts are analysed by Claude AI — your image is not stored.<br>
  SplitTab · Free to use · No account required
</footer>

<div id="loading">
  <div class="loader-ring"></div>
  <div class="loader-status" id="loader-status">Initialising OCR…</div>
  <div class="loader-detail" id="loader-detail">This may take a moment</div>
  <div class="progress-track">
    <div class="progress-bar" id="progress-bar"></div>
  </div>
</div>

<div id="toast"></div>

<script src="https://cdn.jsdelivr.net/npm/tesseract.js@4/dist/tesseract.min.js"></script>
<script>
  // ─── Image helpers ────────────────────────────────────────────────────────

  // Convert a File to { base64, mediaType } for the Claude Vision API.
  // Falls back to JPEG via canvas for unsupported formats (BMP, TIFF, etc.).
  async function fileToBase64(file) {
    const supported = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];
    if (supported.includes(file.type)) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onerror = reject;
        reader.onload  = e => resolve({ base64: e.target.result.split(',')[1], mediaType: file.type });
        reader.readAsDataURL(file);
      });
    }
    // Convert unsupported formats via canvas → JPEG
    return new Promise((resolve, reject) => {
      const img = new Image(), url = URL.createObjectURL(file);
      img.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Image load failed')); };
      img.onload  = () => {
        URL.revokeObjectURL(url);
        const c = document.createElement('canvas');
        c.width = img.width; c.height = img.height;
        c.getContext('2d').drawImage(img, 0, 0);
        const dataUrl = c.toDataURL('image/jpeg', 0.95);
        resolve({ base64: dataUrl.split(',')[1], mediaType: 'image/jpeg' });
      };
      img.src = url;
    });
  }

  // Preprocess image onto a canvas: greyscale + contrast boost + upscale.
  // Returns an HTMLCanvasElement which Tesseract.recognize() accepts directly,
  // avoiding any toBlob/worker-script issues when running from file://.
  async function preprocessImage(file) {
    return new Promise((resolve, reject) => {
      const img = new Image();
      const url = URL.createObjectURL(file);
      img.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Image load failed')); };
      img.onload = () => {
        URL.revokeObjectURL(url);
        try {
          const canvas = document.createElement('canvas');
          // Upscale if small — Tesseract works best at ~300 DPI (~1800px min side)
          let w = img.width, h = img.height;
          const longest = Math.max(w, h);
          if (longest < 1800) {
            const scale = Math.min(1800 / longest, 3);
            w = Math.round(w * scale);
            h = Math.round(h * scale);
          }
          canvas.width = w;
          canvas.height = h;
          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, w, h);

          const imageData = ctx.getImageData(0, 0, w, h);
          const d = imageData.data;
          for (let i = 0; i < d.length; i += 4) {
            // Luminance-weighted greyscale
            const g = 0.299 * d[i] + 0.587 * d[i + 1] + 0.114 * d[i + 2];
            // Contrast stretch: pulls darks darker, lights lighter
            const c = Math.max(0, Math.min(255, (g - 128) * 1.6 + 128));
            d[i] = d[i + 1] = d[i + 2] = c;
          }
          ctx.putImageData(imageData, 0, 0);
          resolve(canvas); // caller passes canvas straight to Tesseract.recognize
        } catch (e) {
          reject(e);
        }
      };
      img.src = url;
    });
  }

  // ─── Claude Vision backend ───────────────────────────────────────────────

  async function processWithClaude(file) {
    updateLoading('Sending to Claude AI…', 'Analysing receipt', 20);
    const { base64, mediaType } = await fileToBase64(file);

    updateLoading('Claude is reading the receipt…', 'Usually under 5 seconds', 40);

    const response = await fetch('https://split-tab.michaeledooley.workers.dev/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        model: 'claude-haiku-4-5-20251001',
        max_tokens: 1024,
        messages: [{
          role: 'user',
          content: [
            {
              type: 'image',
              source: { type: 'base64', media_type: mediaType, data: base64 }
            },
            {
              type: 'text',
              text: `You are a receipt parser. Extract all line items from this restaurant receipt image.

Return ONLY a valid JSON object — no markdown, no explanation, nothing else.

Use this exact structure:
{
  "currency": "£",
  "items": [
    {"name": "Potato Sourdough", "price": 5.50},
    {"name": "Classic Negroni", "price": 14.00}
  ],
  "subtotal": 218.00,
  "serviceCharge": {"name": "Service Charge", "price": 28.25},
  "total": 246.25
}

Rules:
- Include EVERY food and drink line item as a separate object in "items"
- For items shown as "N @ £X.XX / Item Name / £Y.YY": use the item name and the TOTAL price (£Y.YY)
- Combine ALL service charges, tips, and charity donations (e.g. StreetSmart) into "serviceCharge" — sum them if multiple
- Set "serviceCharge" to null if none exists
- Prices must be plain numbers — no currency symbols
- "currency" should be the symbol found on the receipt (£, $, €, etc.)`
            }
          ]
        }]
      })
    });

    if (!response.ok) {
      const err = await response.json().catch(() => ({}));
      throw new Error(err.error?.message || `Claude API error ${response.status}`);
    }

    updateLoading('Parsing response…', 'Almost done', 90);
    const data = await response.json();
    const raw  = data.content[0].text.trim();

    // Strip markdown code fences if Claude added them despite instructions
    const jsonStr = raw.replace(/^```(?:json)?\s*/i, '').replace(/\s*```$/, '').trim();
    const parsed  = JSON.parse(jsonStr);

    // Normalise to the app's internal format + validate
    const currency = parsed.currency || '£';
    const items = (parsed.items || []).map((it, i) => ({
      id: `item_${Date.now()}_${i}`,
      name: it.name || 'Unknown item',
      price: Math.round((parseFloat(it.price) || 0) * 100) / 100
    }));
    const subtotal      = parsed.subtotal != null
      ? { name: 'Subtotal', price: Math.round(parsed.subtotal * 100) / 100 }
      : null;
    const serviceCharge = parsed.serviceCharge
      ? { name: parsed.serviceCharge.name || 'Service Charge',
          price: Math.round((parseFloat(parsed.serviceCharge.price) || 0) * 100) / 100 }
      : null;
    const total = parsed.total != null
      ? { name: 'Total', price: Math.round(parsed.total * 100) / 100 }
      : null;

    // Validation
    const warnings = [];
    const itemsSum  = Math.round(items.reduce((s, i) => s + i.price, 0) * 100) / 100;
    const scPrice   = serviceCharge ? serviceCharge.price : 0;
    const calcTotal = Math.round((itemsSum + scPrice) * 100) / 100;
    if (subtotal && Math.abs(itemsSum - subtotal.price) > 0.10) {
      warnings.push(`Items sum to ${currency}${itemsSum.toFixed(2)} but receipt subtotal shows ${currency}${subtotal.price.toFixed(2)}. Check items are complete.`);
    } else if (total && Math.abs(calcTotal - total.price) > 0.10) {
      warnings.push(`Calculated total (${currency}${calcTotal.toFixed(2)}) differs from receipt total (${currency}${total.price.toFixed(2)}).`);
    }

    return { rawText: raw, currency, items, subtotal, serviceCharge, total, warnings };
  }

  // ─── Tesseract fallback backend ───────────────────────────────────────────

  async function processWithTesseract(file) {
    let imageForOcr;
    try {
      updateLoading('Enhancing image…', 'Boosting contrast', 5);
      imageForOcr = await preprocessImage(file);
    } catch {
      imageForOcr = file;
    }

    const { data: { text } } = await Tesseract.recognize(imageForOcr, 'eng', {
      logger: m => {
        if (m.status === 'loading tesseract core')            updateLoading('Loading OCR engine…', '', 10);
        else if (m.status === 'initializing tesseract')       updateLoading('Initialising…', '', 20);
        else if (m.status === 'loading language traineddata') updateLoading('Loading language data…', '', 30);
        else if (m.status === 'initializing api')             updateLoading('Starting recognition…', '', 40);
        else if (m.status === 'recognizing text') {
          const pct = 40 + Math.round(m.progress * 55);
          updateLoading('Reading receipt…', `${pct}%`, pct);
        }
      }
    });

    updateLoading('Parsing items…', 'Almost done', 98);
    const parsed = parseReceipt(text);
    return {
      rawText: text,
      currency: parsed.currency,
      items: parsed.items,
      serviceCharge: parsed.serviceCharge,
      subtotal: parsed.subtotal,
      total: parsed.total,
      warnings: parsed.warnings
    };
  }

  // ─── Main entry point ────────────────────────────────────────────────────

  async function processReceipt(event) {
    const file = event.target.files[0];
    if (!file) return;
    event.target.value = '';

    showLoading('Preparing…', 'Please wait');

    try {
      const result = await processWithClaude(file);

      sessionStorage.setItem('receiptData', JSON.stringify(result));
      updateLoading('Done!', '', 100);
      setTimeout(() => { window.location.href = 'split.html'; }, 300);

    } catch (err) {
      // If Claude failed, try Tesseract as automatic fallback
      showToast('Claude API failed — falling back to Tesseract OCR.');
      {
        try {
          const result = await processWithTesseract(file);
          result.warnings = result.warnings || [];
          result.warnings.unshift('Claude API failed (' + err.message + '). Used Tesseract OCR instead.');
          sessionStorage.setItem('receiptData', JSON.stringify(result));
          updateLoading('Done!', '', 100);
          setTimeout(() => { window.location.href = 'split.html'; }, 300);
          return;
        } catch { /* fall through to error state */ }
      }
      hideLoading();
      sessionStorage.setItem('receiptData', JSON.stringify({
        rawText: 'ERROR: ' + err.message, currency: '£',
        items: [], serviceCharge: null, subtotal: null, total: null,
        warnings: ['Processing failed: ' + err.message + '. Add items manually below.']
      }));
      showToast('Processing failed — add items manually on the next page.');
      setTimeout(() => { window.location.href = 'split.html'; }, 2000);
    }
  }

  function detectCurrency(text) {
    if (/£/.test(text)) return '£';
    if (/€/.test(text)) return '€';
    if (/¥/.test(text)) return '¥';
    return '$';
  }

  function parseReceipt(rawText) {
    const currSym  = detectCurrency(rawText);
    const warnings = [];
    const items    = [];
    let subtotal     = null;
    let serviceCharge = null;
    let total        = null;

    // ── Patterns ──────────────────────────────────────────────────────────
    // Price at the end of a line (optional currency symbol)
    const priceRe     = /[£$€¥]?\s*(\d{1,5}[.,]\d{2})\s*$/;
    // A line that is ONLY a price (standalone orphan price line)
    const priceOnlyRe = /^[£$€¥]?\s*\d{1,5}[.,]\d{2}\s*$/;
    // "N @ unit_price" quantity-only line (multi-line receipt format)
    const qtyOnlyRe   = /^\d+\s*@\s*[\d.,]+\s*$/;

    // Lines to skip entirely (headers, footers, metadata)
    const skipRe = /^(date|time|server|table\s*\d|order\s*#|receipt\s*#|invoice|thank\s*you|tel\s*[:#]|phone|www\.|http|address|chk\s*#|tbl\s*#|guests|last\s*serv|follow\s*us|sales[\s\-]*vat|vat\s*rate|vat\s*amt|vat\s*no|---|\*\*\*|={3,})/i;

    // Classification patterns
    // totalRe: "TOTAL:", "TOTAL", "TOTAL DUE", etc.
    const totalRe    = /\b(total\s*due|amount\s*due|balance\s*due|grand\s*total|total\s*payable)\b|^\s*total\s*:?\s*$/i;
    const subtotalRe = /\b(sub[\s-]?total|food\s*total|net\s*total)\b/i;
    // serviceRe: s? handles OCR dropping the leading 'S' (e.g. "Ervice Charge")
    const serviceRe  = /\b(s?ervice\s*charge|s?ervice|gratuity|tip|srv\s*chg|surcharge|streetsmart|street\s*smart)\b/i;
    const taxRe      = /\b(tax|vat|gst|hst|sales\s*tax)\b/i;

    // ── Pre-process raw lines ─────────────────────────────────────────────
    // Goals:
    //  1. Drop "N @ unit_price" quantity-only lines (multi-line item format:
    //     name + total appear on the following line)
    //  2. Merge orphaned name lines with the standalone price line that
    //     follows (OCR sometimes splits "Item Name    5.50" across two lines)
    //  3. Drop VAT-table rows (3+ price-like tokens on one line)
    const rawLines = rawText.split('\n').map(l => {
      // Normalise common OCR price artifacts before any pattern matching:
      // "5. 50" → "5.50"  (space after decimal point)
      // "5 .50" → "5.50"  (space before decimal point)
      return l.trim()
        .replace(/(\d)\.\s+(\d{2})(?=\s|$)/g, '$1.$2')
        .replace(/(\d)\s+\.(\d{2})(?=\s|$)/g,  '$1.$2');
    }).filter(Boolean);
    const lines    = [];

    for (let i = 0; i < rawLines.length; i++) {
      const line = rawLines[i];

      if (skipRe.test(line) || line.length < 2) continue;

      // Drop "N @ unit_price" quantity-only lines
      if (qtyOnlyRe.test(line)) continue;

      // Drop lines with 3+ price-like tokens (e.g. VAT breakdown table)
      if ((line.match(/\b\d{1,5}[.,]\d{2}\b/g) || []).length >= 3) continue;

      const hasPrice = priceRe.test(line);

      if (!hasPrice) {
        // Name-only line — look ahead for an immediately following standalone price
        let j = i + 1;
        while (j < rawLines.length && rawLines[j].trim().length < 2) j++;
        const nextLine = j < rawLines.length ? rawLines[j].trim() : '';
        if (priceOnlyRe.test(nextLine)) {
          // Merge: "Item Name" + "5.50" → "Item Name    5.50"
          lines.push(line + '    ' + nextLine);
          i = j; // consume the price line so it isn't processed again
        }
        // If no standalone price follows, this name has no parseable price — skip it
        continue;
      }

      lines.push(line);
    }

    // ── Main classification pass ──────────────────────────────────────────
    for (const line of lines) {
      const m = line.match(priceRe);
      if (!m) continue;

      // Normalise price: handle European thousands format (1.234,56 → 1234.56)
      let priceStr = m[1];
      if (/^\d{1,3}\.\d{3},\d{2}$/.test(priceStr)) {
        priceStr = priceStr.replace('.', '').replace(',', '.');
      } else {
        priceStr = priceStr.replace(',', '.');
      }
      const price = parseFloat(priceStr);
      if (isNaN(price) || price <= 0) continue;

      // Extract name — everything before the price match
      let name = line.slice(0, line.lastIndexOf(m[0])).trim();
      name = name.replace(/[£$€¥]/g, '').trim();
      name = name.replace(/^\d+\s*@\s*[\d.,]+\s*/, ''); // "2 @ 7.00 Name" (merged OCR line)
      name = name.replace(/^\d+\s*[×xX]\s*/, '');        // "2x " or "2 × " quantity prefix
      name = name.replace(/^\d{1,3}\.\s+/, '');           // "1. " item-number prefix
      name = name.replace(/^\d+\s+/, '');                  // "1 " bare leading quantity
      name = name.replace(/\s{2,}/g, ' ').trim();

      if (!name || name.length < 2) continue;

      // Classify
      if (totalRe.test(name)) {
        if (!total || price > total.price) total = { name: 'Total', price };
      } else if (subtotalRe.test(name)) {
        subtotal = { name: 'Subtotal', price };
      } else if (serviceRe.test(name) || taxRe.test(name)) {
        if (!serviceCharge) {
          serviceCharge = { name: toTitleCase(name), price };
        } else {
          // Sum all service-type charges (e.g. Service Charge + StreetSmart)
          serviceCharge.price = Math.round((serviceCharge.price + price) * 100) / 100;
        }
      } else {
        items.push({
          id: `item_${Date.now()}_${Math.random().toString(36).slice(2, 6)}`,
          name: toTitleCase(name),
          price: Math.round(price * 100) / 100
        });
      }
    }

    // ── Derive any missing summary values ─────────────────────────────────
    if (items.length > 0 && !subtotal) {
      const sum = items.reduce((s, i) => s + i.price, 0);
      subtotal = { name: 'Subtotal', price: Math.round(sum * 100) / 100 };
    }
    if (!total) {
      const s  = subtotal      ? subtotal.price      : 0;
      const sc = serviceCharge ? serviceCharge.price : 0;
      total = { name: 'Total', price: Math.round((s + sc) * 100) / 100 };
    }

    // ── Validate: check parsed items sum against scanned totals ───────────
    const itemsSum  = Math.round(items.reduce((s, i) => s + i.price, 0) * 100) / 100;
    const scPrice   = serviceCharge ? serviceCharge.price : 0;
    const calcTotal = Math.round((itemsSum + scPrice) * 100) / 100;

    if (subtotal && Math.abs(itemsSum - subtotal.price) > 0.10) {
      warnings.push(
        `Scanned items sum to ${currSym}${itemsSum.toFixed(2)} but the receipt subtotal shows ${currSym}${subtotal.price.toFixed(2)}. Some items may be missing — please check and add them manually.`
      );
    } else if (!subtotal && total && Math.abs(calcTotal - total.price) > 0.10) {
      warnings.push(
        `Calculated total (${currSym}${calcTotal.toFixed(2)}) differs from the scanned receipt total (${currSym}${total.price.toFixed(2)}). Some items may be missing.`
      );
    }

    return { items, subtotal, serviceCharge, total, warnings, currency: currSym };
  }

  function toTitleCase(str) {
    return str.toLowerCase().replace(/\b\w/g, c => c.toUpperCase());
  }

  // ─── UI helpers ──────────────────────────────────────────────────────────

  function showLoading(status, detail) {
    document.getElementById('loading').classList.add('show');
    document.getElementById('loader-status').textContent = status;
    document.getElementById('loader-detail').textContent = detail;
    document.getElementById('progress-bar').style.width = '0%';
  }

  function updateLoading(status, detail, pct) {
    document.getElementById('loader-status').textContent = status;
    document.getElementById('loader-detail').textContent = detail;
    document.getElementById('progress-bar').style.width = pct + '%';
  }

  function hideLoading() {
    document.getElementById('loading').classList.remove('show');
  }

  function showToast(msg) {
    const t = document.getElementById('toast');
    t.textContent = msg;
    t.style.display = 'block';
    setTimeout(() => { t.style.display = 'none'; }, 4000);
  }
</script>
</body>
</html>
